## 集合

### 1. ArrayList (P32 ~35)

集合是数组实现的，那么就会有两个问题：

> 1. 调用无参ArrayList时，数组的容量是多少？
>
>    
>
>    容量为0。我们 结合源码来看
>
> ```java
> public ArrayList(){
> 	this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
> }
> ```
>
>  
>
> 2. 调用有参的ArrayList构造方法时呢？
>    
>
>    这又分为两种情况
>
>    第一种情况，参数的类型是一个int类型的整数参数。在原码中，参数的变量类型和变量名为**int initialCapacity**. 因此，数组的容量就是initialCapacity的大小。
>
>    第二种情况，参数的类型是集合类型的。在源码中，参数的类型和变量名为
>
>    ```java
>    public ArrayList(Collection<? extends c>){
>    	....
>    }
>    ```
>
>    那么，数组的大小就是集合的大小







#### 1.1 ArrayList的扩容机制

存不了东西，就会触发扩容。

> 默认：0
> 第一次：10    并把元素添加到新数组索引0的位置。 最后用新数组替换旧数组。
> 第二次：到10的时候，填满了。扩容大小：上次的1.5倍，也就是15.
> 第三次：15 * 1.5是小数？

虽然看上去是小数，但是底层实际上是用了**移位**或者说是为**位运算**来实现。先找到一般。15 >> 1 = 7.     7 + 15 = 22. 因此，第三次扩容大小为22。

前20次扩容样例， 可以试着自己推一下
![image-20230317172244230](C:\Users\18795\AppData\Roaming\Typora\typora-user-images\image-20230317172244230.png)

---

上面讨论的都是add方法添加元素，addAll()方法不一样。

addAll()也是往ArrayList中添加元素，但是是**一次性**添加一个集合。

addAll()有两种情况需要分别讨论

第一种：ArrayList为空，没有其他元素

第二种：ArrayList中已经有一些元素了。



刚开始数组长度为0。 比如要添加存储了1、2、3的数组。 3个元素显然放不下，需要扩容。

​	第一次： 扩容成10.  （**此10非上面的10**）

​	为什么说这个10和上面add不一样呢? 以添加一个长度为11的集合为例。空数组会被扩容成11.

​	这是因为addAll()的运行规律不同。当他发现原始的容量不够时。他会将下次需要扩容的大小和集合中元素的个数进行对比，取较大值，作为需要扩容的数量。在这里，原始容量为0，根据add()的扩容机制，下次扩容取10. 但是，因为要添加的集合长度为11， 11 > 10. 因此就扩容到了11.

​	再来一个例子，ArrayList中已经有10个元素了。 这时候要添加3个元素。按照1.5倍扩容机制来讲，将会被扩容5，扩容成15。而实际元素个数为10 + 3 = 13，  15 > 13，因此，数组被扩容成了15.

​	最后一个例子，ArrayList中已经有10个元素了。 这时候要添加6个元素。按照1.5倍扩容机制来讲，下一次将会被扩容5，扩容成15。而实际元素个数为10 + 6 = 16，  15 < 16，因此，数组被扩容成了16.

------

总结：

![image-20230317174545727](C:\Users\18795\AppData\Roaming\Typora\typora-user-images\image-20230317174545727.png)

---

#### 1.2 Iterator迭代器的fail-fast和fail-safe



* 两个和迭代器相关的特性。

迭代器的作用，就是来遍历集合的。Set、 List集合等等。

那么就出现了一个问题，正在遍历的时候，允不允许别人也遍历这个集合呢？

Fail-fast和fail-safe就是两种策略。

fail-fast, 一旦发现遍历的同时其他人来修改，立刻抛异常。

fail-safe, 如果发现遍历的同时有其他人来修改，可以牺牲一致性，来让遍历完成。不报错。



对于ArrayList来讲，它的迭代器是fail-fast。如果发现被修改了，会完成当前的即将遍历的元素，然后立刻抛出 **ConcurrentModificaitonException**异常，也被称为**并发修改异常**。



fail-safe的一个典型实例是 CopyOnWriteArrayList。 

